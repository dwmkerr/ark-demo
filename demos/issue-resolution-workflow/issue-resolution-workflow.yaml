apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: issue-resolution-workflow
  annotations:
    workflows.argoproj.io/title: "Issue Resolution"
    workflows.argoproj.io/description: |
      Reviews open issues in a GitHub repository and suggests resolution plans using an ARK agent.
spec:
  entrypoint: main
  serviceAccountName: argo-workflow

  volumeClaimTemplates:
  - metadata:
      name: workspace
    spec:
      accessModes: [ "ReadWriteMany" ]
      resources:
        requests:
          storage: 10Gi
      storageClassName: standard

  arguments:
    parameters:
    - name: github-repo
      value: "mckinsey/agents-at-scale-ark"
      description: "GitHub repository in org/repo format"

    - name: updated-since
      value: "2000-01-01T00:00:00Z"
      description: "Only review issues updated since this timestamp. Format: ISO8601."

    - name: issue-ids
      value: ""
      description: "Comma-separated issue IDs to review (e.g., 234,56,2). If empty, uses all open issues matching filters."

    - name: label-filter
      value: ""
      description: "Only include issues with this label (e.g., 'bug'). Empty means all issues."

    - name: gh-token
      value: ""
      description: "GitHub token for API access."

    - name: issue-resolution-agent
      value: "issue-resolution-agent"
      description: "Ark agent name for issue analysis"

    - name: planner-agent
      value: "planner-agent"
      description: "Ark agent name for implementation planning"

  templates:
  - name: main
    dag:
      tasks:
      - name: prepare-and-validate
        template: prepare-and-validate

      - name: request-approval
        template: request-approval
        depends: "prepare-and-validate"
        arguments:
          artifacts:
          - name: workflow-plan
            from: "{{tasks.prepare-and-validate.outputs.artifacts.workflow-plan}}"

      - name: analyze-issues
        template: analyze-issue
        depends: "request-approval"
        arguments:
          parameters:
          - name: issue-id
            value: "{{item}}"
        withParam: "{{tasks.prepare-and-validate.outputs.parameters.issue-ids}}"

      - name: create-plan
        template: create-plan
        depends: "analyze-issues"
        arguments:
          parameters:
          - name: issue-id
            value: "{{item}}"
        withParam: "{{tasks.prepare-and-validate.outputs.parameters.issue-ids}}"

      - name: submit-plan
        template: submit-plan
        depends: "create-plan"
        arguments:
          parameters:
          - name: issue-id
            value: "{{item}}"
        withParam: "{{tasks.prepare-and-validate.outputs.parameters.issue-ids}}"

      - name: summarize
        template: summarize
        depends: "submit-plan.Succeeded || submit-plan.Failed"

  - name: prepare-and-validate
    metadata:
      annotations:
        workflows.argoproj.io/description: "Validate prerequisites and fetch issues"
    script:
      image: alpine/k8s:1.28.13
      command: [sh]
      env:
      - name: GH_TOKEN
        value: "{{workflow.parameters.gh-token}}"
      volumeMounts:
      - name: workspace
        mountPath: /workspace
      source: |
        set -e -o pipefail
        apk add --no-cache jq curl >/dev/null 2>&1

        # Validate prerequisites
        kubectl get mcpserver github
        kubectl wait --for=condition=Ready mcpserver/github --timeout=5s
        agent_name="{{workflow.parameters.issue-resolution-agent}}"
        kubectl get agent "${agent_name}"

        # Validate GitHub token if provided
        gh_token="{{workflow.parameters.gh-token}}"
        gh_user=""
        gh_scopes=""
        gh_token_type=""
        if [ -n "${gh_token}" ]; then
          token_response=$(curl -sS -D - -o /tmp/user.json \
            -H "Authorization: token ${gh_token}" \
            "https://api.github.com/user" 2>/dev/null)
          http_code=$(echo "$token_response" | grep -i "^HTTP" | tail -1 | awk '{print $2}')
          if [ "$http_code" = "200" ]; then
            gh_user=$(jq -r '.login // empty' /tmp/user.json)
            gh_scopes=$(echo "$token_response" | grep -i "^x-oauth-scopes:" | cut -d: -f2- | tr -d '\r' | xargs)
            if [ -n "$gh_scopes" ]; then
              gh_token_type="classic"
            else
              gh_token_type="⚠️ fine-grained (scopes not available)"
            fi
          else
            gh_user="validation failed (HTTP ${http_code})"
            gh_token_type="unknown"
          fi
        fi

        # Fetch issues
        repo="{{workflow.parameters.github-repo}}"
        issue_ids_param="{{workflow.parameters.issue-ids}}"
        updated_since="{{workflow.parameters.updated-since}}"
        label_filter="{{workflow.parameters.label-filter}}"
        workflow_id="{{workflow.name}}"
        workspace_path="/workspace/${workflow_id}"
        mkdir -p "${workspace_path}"
        issues_json="${workspace_path}/issues.json"

        if [ -n "$issue_ids_param" ]; then
          echo "[]" > "${issues_json}"
          for id in $(echo "$issue_ids_param" | tr ',' ' '); do
            response=$(curl -sS -w "\n%{http_code}" \
              "https://api.github.com/repos/${repo}/issues/${id}")
            http_code=$(echo "$response" | tail -1)
            body=$(echo "$response" | sed '$d')
            if [ "$http_code" = "200" ]; then
              echo "$body" | jq '{number: .number, title: .title, url: .html_url, labels: [.labels[].name]}' > /tmp/issue.json
              jq -s '.[0] + [.[1]]' "${issues_json}" /tmp/issue.json > /tmp/merged.json
              mv /tmp/merged.json "${issues_json}"
            else
              echo "Warning: Issue #${id} not found (HTTP ${http_code})" >&2
            fi
          done
        else
          api_url="https://api.github.com/repos/${repo}/issues?state=open&per_page=100"
          [ -n "$label_filter" ] && api_url="${api_url}&labels=${label_filter}"
          curl -sS "${api_url}" \
            | jq --arg since "${updated_since}" \
              '[.[] | select(.pull_request == null) | select(.updated_at > $since) | {number: .number, title: .title, url: .html_url, labels: [.labels[].name]}]' \
            > "${issues_json}"
        fi

        # Generate workflow plan
        issue_count=$(jq 'length' "${issues_json}")

        cat > /tmp/workflow-plan.md <<EOF
        # Issue Resolution Workflow Plan

        ## Configuration
        - **Repository:** ${repo}
        - **Agent:** ${agent_name}
        - **Updated Since:** ${updated_since}
        - **Label Filter:** ${label_filter:-all}
        - **GitHub Token User:** ${gh_user:-not provided}
        - **GitHub Token Type:** ${gh_token_type:-⚠️ n/a}
        - **GitHub Token Scopes:** ${gh_scopes:-⚠️ n/a}

        ## Issues to Analyze (${issue_count})

        | # | Title |
        |---|-------|
        EOF

        jq -r '.[] | "| [#\(.number)](\(.url)) | \(.title) |"' "${issues_json}" >> /tmp/workflow-plan.md

        cat >> /tmp/workflow-plan.md <<EOF

        ## Approval Required

        To approve: \`argo resume ${workflow_id}\`
        To reject: \`argo terminate ${workflow_id}\`
        EOF

        echo "Found ${issue_count} issues to analyze"
        cat /tmp/workflow-plan.md
        jq '[.[].number]' "${issues_json}" > /tmp/issue-ids.json
    outputs:
      parameters:
      - name: issue-ids
        valueFrom:
          path: /tmp/issue-ids.json
      artifacts:
      - name: workflow-plan
        path: /tmp/workflow-plan.md
        archive:
          none: {}
      - name: issues
        path: /workspace/{{workflow.name}}/issues.json
        archive:
          none: {}

  - name: request-approval
    metadata:
      annotations:
        workflows.argoproj.io/description: |
          Review the workflow plan and issues before proceeding.

          To approve: argo resume {{workflow.name}}
          To reject: argo terminate {{workflow.name}}
    inputs:
      artifacts:
      - name: workflow-plan
    suspend: {}

  - name: analyze-issue
    metadata:
      annotations:
        workflows.argoproj.io/description: "Analyze an issue and suggest a resolution plan"
    inputs:
      parameters:
      - name: issue-id
    script:
      image: alpine/k8s:1.28.13
      command: [sh]
      volumeMounts:
      - name: workspace
        mountPath: /workspace
      source: |
        set -e -o pipefail

        issue_id="{{inputs.parameters.issue-id}}"
        workflow_id="{{workflow.name}}"
        workspace_path="/workspace/${workflow_id}/${issue_id}"
        max_retries=5
        retry_wait=300

        for attempt in $(seq 1 $max_retries); do
          query_name="${workflow_id}-analyze-issue-${issue_id}-${attempt}"
          echo "Attempt ${attempt}/${max_retries} for issue #${issue_id}" >&2

          kubectl create -f - <<EOF >&2
        apiVersion: ark.mckinsey.com/v1alpha1
        kind: Query
        metadata:
          name: ${query_name}
          labels:
            workflow: "{{workflow.name}}"
          annotations:
            ark.mckinsey.com/workflow-name: "{{workflow.name}}"
        spec:
          input: |
            Analyze issue #${issue_id} in repository {{workflow.parameters.github-repo}}.

            Review the issue details and provide a resolution plan in Markdown format.

            Your analysis should include:
            1. Issue summary - what is being requested or reported
            2. Classification - bug, feature request, documentation, etc.
            3. Suggested approach - high-level steps to resolve
            4. Potential challenges or considerations
            5. Estimated complexity (low/medium/high)
            6. Questions for the requester (if the issue lacks sufficient detail)

            If important details are missing, include specific questions that would help clarify the issue.

            Note: You cannot clone the repository. Base your analysis on the issue description and any linked context.

          targets:
          - type: agent
            name: {{workflow.parameters.issue-resolution-agent}}
          sessionId: {{workflow.name}}
          timeout: 10m
          ttl: 24h
        EOF

          kubectl wait --for=condition=Completed --timeout=10m query/${query_name}

          phase=$(kubectl get query "${query_name}" -o jsonpath='{.status.phase}')
          if [ "${phase}" != "error" ]; then
            # Success - save analysis to workspace.
            analysis_content=$(kubectl get query "${query_name}" -o jsonpath='{.status.responses[0].content}')
            mkdir -p "${workspace_path}"
            echo "${analysis_content}" > "${workspace_path}/analysis.md"
            cat "${workspace_path}/analysis.md" | tee /tmp/analysis.txt
            exit 0
          fi

          # Query failed - log error and retry.
          error_msg=$(kubectl get query "${query_name}" -o jsonpath='{.status.responses[0].raw}')
          echo "Query failed: ${error_msg}" >&2

          if [ "$attempt" -lt "$max_retries" ]; then
            echo "Waiting ${retry_wait}s before retry..." >&2
            sleep $retry_wait
          fi
        done

        # All retries exhausted.
        echo "ERROR: All ${max_retries} attempts failed" > /tmp/analysis.txt
        exit 1
    outputs:
      parameters:
      - name: analysis
        valueFrom:
          path: /tmp/analysis.txt
      artifacts:
      - name: analysis
        path: /tmp/analysis.txt
        archive:
          none: {}

  - name: create-plan
    metadata:
      annotations:
        workflows.argoproj.io/description: "Create implementation plan for an issue"
    inputs:
      parameters:
      - name: issue-id
    script:
      image: alpine/k8s:1.28.13
      command: [sh]
      volumeMounts:
      - name: workspace
        mountPath: /workspace
      source: |
        set -e -o pipefail
        apk add --no-cache jq >/dev/null 2>&1

        issue_id="{{inputs.parameters.issue-id}}"
        workflow_id="{{workflow.name}}"
        workspace_path="/workspace/${workflow_id}/${issue_id}"
        analysis_file="${workspace_path}/analysis.md"
        max_retries=3
        retry_wait=300

        if [ ! -f "${analysis_file}" ]; then
          echo "Analysis file not found: ${analysis_file}" >&2
          exit 1
        fi
        analysis_content=$(cat "${analysis_file}")

        # Build the prompt with analysis content
        prompt_text="Create an implementation plan for issue #${issue_id} in repository {{workflow.parameters.github-repo}}.

        Here is the issue analysis:
        ${analysis_content}

        Based on this analysis, create a detailed implementation plan in Markdown format:

        ## Specification
        - Exact changes required (files, functions, APIs)
        - Data structures or schemas if applicable
        - Edge cases to handle

        ## Implementation Steps
        1. [First step with specific details]
        2. [Second step...]

        ## Testing Plan
        - Unit tests to add
        - Integration tests if needed

        ## Acceptance Criteria
        - [ ] Criterion 1
        - [ ] Criterion 2"

        for attempt in $(seq 1 $max_retries); do
          query_name="${workflow_id}-plan-${issue_id}-${attempt}"
          echo "Attempt ${attempt}/${max_retries} for issue #${issue_id}" >&2

          # Use jq to properly escape the prompt content
          jq -n \
            --arg name "${query_name}" \
            --arg workflow "{{workflow.name}}" \
            --arg input "$prompt_text" \
            --arg agent "{{workflow.parameters.planner-agent}}" \
            '{
              apiVersion: "ark.mckinsey.com/v1alpha1",
              kind: "Query",
              metadata: {
                name: $name,
                labels: { workflow: $workflow }
              },
              spec: {
                input: $input,
                targets: [{ type: "agent", name: $agent }],
                sessionId: $workflow,
                timeout: "10m",
                ttl: "24h"
              }
            }' | kubectl create -f - >&2

          kubectl wait --for=condition=Completed --timeout=10m query/${query_name}

          phase=$(kubectl get query "${query_name}" -o jsonpath='{.status.phase}')
          if [ "${phase}" != "error" ]; then
            plan_content=$(kubectl get query "${query_name}" -o jsonpath='{.status.responses[0].content}')
            mkdir -p "${workspace_path}"
            echo "${plan_content}" > "${workspace_path}/plan.md"
            cat "${workspace_path}/plan.md" | tee /tmp/plan.md
            exit 0
          fi

          error_msg=$(kubectl get query "${query_name}" -o jsonpath='{.status.responses[0].raw}')
          echo "Query failed: ${error_msg}" >&2

          if [ "$attempt" -lt "$max_retries" ]; then
            echo "Waiting ${retry_wait}s before retry..." >&2
            sleep $retry_wait
          fi
        done

        echo "ERROR: All ${max_retries} attempts failed" > /tmp/plan.md
        exit 1
    outputs:
      artifacts:
      - name: plan
        path: /tmp/plan.md
        archive:
          none: {}

  - name: submit-plan
    metadata:
      annotations:
        workflows.argoproj.io/description: "Post implementation plan to issue"
    inputs:
      parameters:
      - name: issue-id
    script:
      image: badouralix/curl-jq:latest
      command: [sh]
      env:
      - name: GH_TOKEN
        value: "{{workflow.parameters.gh-token}}"
      volumeMounts:
      - name: workspace
        mountPath: /workspace
      source: |
        set -e -o pipefail

        issue_id="{{inputs.parameters.issue-id}}"
        repo="{{workflow.parameters.github-repo}}"
        workflow_id="{{workflow.name}}"
        plan_file="/workspace/${workflow_id}/${issue_id}/plan.md"
        marker="<!-- ark:plan -->"

        if [ ! -f "${plan_file}" ]; then
          echo "Plan file not found: ${plan_file}" >&2
          exit 1
        fi
        plan_content=$(cat "${plan_file}")

        # Build comment body and save to file for safe JSON encoding
        {
          echo "${marker}"
          echo "## Implementation Plan"
          echo ""
          echo "<details>"
          echo "<summary>Click to expand plan</summary>"
          echo ""
          cat "${plan_file}"
          echo ""
          echo "</details>"
          echo ""
          echo "---"
          echo "*Generated by [Issue Resolution Workflow](https://github.com/dwmkerr/ark-demo) (${workflow_id})*"
        } > /tmp/comment_body.txt

        # Check for existing plan comment
        comments_response=$(curl -sS \
          -H "Authorization: token ${GH_TOKEN}" \
          "https://api.github.com/repos/${repo}/issues/${issue_id}/comments")

        existing_id=$(echo "$comments_response" | jq -r --arg marker "$marker" \
          'if type == "array" then .[] | select(.body | contains($marker)) | .id else empty end' | head -1)

        # Create JSON payload from file
        json_payload=$(jq -n --rawfile body /tmp/comment_body.txt '{body: $body}')

        if [ -n "${existing_id}" ]; then
          curl -sS -X PATCH \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${repo}/issues/comments/${existing_id}" \
            -d "$json_payload" >/dev/null
          echo "Updated plan comment ${existing_id}"
        else
          curl -sS -X POST \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${repo}/issues/${issue_id}/comments" \
            -d "$json_payload" >/dev/null
          echo "Created plan comment"
        fi

        # Add label
        curl -sS -X POST \
          -H "Authorization: token ${GH_TOKEN}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${repo}/issues/${issue_id}/labels" \
          -d '{"labels":["ark:planning:in-progress"]}' >/dev/null 2>&1 || true

        echo "Plan submitted for issue #${issue_id}"

  - name: summarize
    metadata:
      annotations:
        workflows.argoproj.io/description: "Summarize all issue analyses"
    script:
      image: badouralix/curl-jq:latest
      command: [sh]
      volumeMounts:
      - name: workspace
        mountPath: /workspace
      source: |
        set -e -o pipefail

        workflow_id="{{workflow.name}}"
        repo="{{workflow.parameters.github-repo}}"
        workspace_path="/workspace/${workflow_id}"
        issues_json="${workspace_path}/issues.json"
        summary_html="/tmp/summary.html"

        [ -d "${workspace_path}" ] || { echo "Workspace directory not found: ${workspace_path}"; exit 1; }

        {
          echo "<h1>Issue Resolution Summary</h1>"
          echo "<p>Workflow: ${workflow_id}<br>"
          echo "Repository: <a href=\"https://github.com/${repo}\">${repo}</a></p>"
          echo "<h2>Analyzed Issues</h2>"
          echo "<table border=\"1\" cellpadding=\"8\" cellspacing=\"0\">"
          echo "<tr><th>Issue</th><th>Title</th><th>Analysis</th><th>Plan</th></tr>"
        } > "${summary_html}"

        jq -r '.[] | "\(.number)|\(.title)|\(.url)"' "${issues_json}" | while IFS='|' read -r number title url; do
          if [ -f "${workspace_path}/${number}/analysis.md" ]; then
            analysis_cell="✓"
          else
            analysis_cell="-"
          fi
          if [ -f "${workspace_path}/${number}/plan.md" ]; then
            plan_cell="✓"
          else
            plan_cell="-"
          fi
          echo "<tr><td><a href=\"${url}\">#${number}</a></td><td>${title}</td><td>${analysis_cell}</td><td>${plan_cell}</td></tr>" >> "${summary_html}"
        done

        echo "</table>" >> "${summary_html}"
        cat "${summary_html}"
    outputs:
      artifacts:
      - name: summary
        path: /tmp/summary.html
        archive:
          none: {}
---
apiVersion: ark.mckinsey.com/v1alpha1
kind: Agent
metadata:
  name: issue-resolution-agent
spec:
  modelRef:
    name: default

  prompt: |
    You are an issue resolution assistant. You help analyze GitHub issues by:
    1. Understanding the issue context and requirements
    2. Classifying the type of issue (bug, feature, docs, etc.)
    3. Suggesting a resolution approach
    4. Identifying when more information is needed from the requester

    Provide clear, actionable plans that developers can follow. If the issue lacks
    sufficient detail to provide a good resolution plan, include a "Questions for
    the Requester" section with specific questions that would help clarify the issue.

  tools:
  - name: github-issue-read
    type: custom
  - name: github-get-file-contents
    type: custom
  - name: github-list-issues
    type: custom
  - name: github-search-issues
    type: custom
  - name: github-search-code
    type: custom
  - name: github-list-branches
    type: custom
  - name: github-list-commits
    type: custom
  - name: github-get-commit
    type: custom
---
apiVersion: ark.mckinsey.com/v1alpha1
kind: Agent
metadata:
  name: planner-agent
spec:
  modelRef:
    name: default

  prompt: |
    You are a technical planner. Given an issue analysis, create detailed implementation plans.

    Your plans should be:
    - Specific and actionable
    - Include file paths and function names where possible
    - Have clear acceptance criteria
    - Be implementable by a developer unfamiliar with the codebase

  tools:
  - name: github-issue-read
    type: custom
  - name: github-get-file-contents
    type: custom
  - name: github-search-code
    type: custom
  - name: github-list-branches
    type: custom
